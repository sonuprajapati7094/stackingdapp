<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Full Staking DApp ‚Äî Dashboard</title>

  <!-- ethers v5 -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>

  <style>
    :root{
      --bg:#0b0d0f; --card:#0f1214; --muted:#9aa4b2; --accent:#ffd86b;
      --panel:#121416; --success:#00c176; --danger:#ff6b6b;
    }
    body{margin:0;font-family:Inter,Arial,sans-serif;background:var(--bg);color:#e6eef6;}
    header{padding:18px 24px;text-align:center;background:linear-gradient(90deg,#081018,#0d1016);box-shadow:0 2px 8px rgba(0,0,0,0.5);}
    header h1{margin:0;color:var(--accent);font-size:20px;}
    .topbar{display:flex;justify-content:flex-end;gap:12px;padding:12px 24px;align-items:center;max-width:1180px;margin:0 auto;}
    .wallet-btn{background:var(--accent);color:#000;padding:8px 14px;border-radius:8px;border:0;font-weight:600;cursor:pointer;}
    .container{padding:20px;display:grid;grid-template-columns:360px 1fr;gap:18px;max-width:1180px;margin:18px auto;}
    .left{display:flex;flex-direction:column;gap:14px;}
    .card{background:var(--card);border-radius:12px;padding:14px;box-shadow:0 6px 20px rgba(0,0,0,0.4);}
    .card h2{margin:0 0 10px 0;color:var(--accent);font-size:16px;}
    .muted{color:var(--muted);font-size:13px;}
    input, textarea{width:100%;padding:10px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:var(--panel);color:#fff;box-sizing:border-box;}
    .small-btn{padding:10px 12px;border-radius:8px;border:0;background:#2a2f35;color:#fff;cursor:pointer;margin-top:8px;}
    .accent-btn{background:var(--accent);color:#000;border:0;padding:10px 12px;border-radius:8px;cursor:pointer;font-weight:700;margin-top:8px;}
    .right{display:flex;flex-direction:column;gap:14px;}
    .grid-4{display:grid;grid-template-columns:repeat(4,1fr);gap:12px;}
    .value{font-size:18px;font-weight:700;color:#fff;}
    .label{font-size:12px;color:var(--muted);margin-top:6px;}
    table{width:100%;border-collapse:collapse;margin-top:8px;font-size:13px;}
    th,td{padding:10px 8px;border-bottom:1px solid rgba(255,255,255,0.03);text-align:left;}
    th{color:var(--accent);font-weight:700;}
    .center{text-align:center;}
    footer{padding:14px;text-align:center;color:var(--muted);font-size:12px;}
    @media(max-width:980px){.container{grid-template-columns:1fr;padding:12px;}.grid-4{grid-template-columns:repeat(2,1fr);}}
    .pill{display:inline-block;padding:6px 10px;border-radius:16px;background:#222;color:#fff;font-weight:600;}
    #disclaimer {
  transition: all 0.3s ease;
}
#disclaimer:hover {
  background: rgba(255,255,255,0.05);
  transform: scale(1.01);
}
#disclaimer p {
  margin: 6px 0;
}
  </style>
</head>
<body>
<header><h1>USDT Staking ‚Äî Full DApp</h1></header>
<div class="topbar">
  <div id="walletDisplay" class="muted">Not connected</div>
  <button id="connectBtn" class="wallet-btn">Connect Wallet</button>
</div>

<main class="container">

  <!-- LEFT: Actions -->
  <div class="left">

    <div class="card">
      <h2>Stake USDT</h2>
      <div class="muted">Min stake: <strong>20 USDT</strong> ‚Äî multiples of 20</div>
      <!-- main stake input -->
      <input id="stakeAmt" type="number" placeholder="Enter amount (20,40...)" />
      <div style="display:flex;gap:10px;margin-top:8px">
        <button id="approveBtn" class="small-btn">Quick Approve</button>
        <button id="stakeBtn" class="accent-btn">Stake Now</button>
      </div>
      <div id="stakeNote" class="muted" style="margin-top:8px">Tip: Approve once then stake.</div>
    </div>

    <div class="card">
      <h2>P2P Stake (Stake For)</h2>
      <div class="muted">Stake for another wallet ‚Äî no 5% fee (owner required as refForRefUser)</div>
      <input id="p2pAmount" type="number" placeholder="P2P amount (min 20)" />
      <input id="p2pAddress" type="text" placeholder="Recipient wallet address" style="margin-top:8px" />
      <button id="stakeForBtn" class="accent-btn" style="margin-top:10px">Stake For (P2P)</button>
    </div>

    <div class="card">
      <h2>Your Referral Link</h2>
      <input id="refLink" type="text" readonly placeholder="Connect wallet to generate link" />
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="copyLink" class="small-btn">Copy Referral Link</button>
        <button id="showTeam" class="small-btn">Show Team</button>
      </div>
      <div class="muted" style="margin-top:8px">Users who register via this link will credit you referral income.</div>
    </div>

    <div class="card">
      <h2>Withdraw</h2>
      <div class="muted">Minimum withdraw 20 USDT (admin approval applies)</div>
      <input id="withdrawAmt" type="number" placeholder="20, 40, 60 ..." />
      <button id="requestWithdraw" class="accent-btn" style="margin-top:8px">Request Withdraw</button>
      <div id="withdrawStatus" class="muted" style="margin-top:8px">No withdraw requests yet.</div>
    </div>

  </div>

  <!-- RIGHT: Dashboard -->
  <div class="right">

    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><h2>Wallet Balances & Income</h2><div class="muted">Instant / Level / ROI</div></div>
        <div><button id="refreshBtn" class="small-btn">Refresh</button></div>
      </div>

      <div style="margin-top:12px" class="grid-4">
        <div class="card" style="background:#0b0d0f;padding:12px;">
          <div class="label">Instant Income</div>
          <div class="value" id="instantIncome">0.000000 USDT</div>
        </div>
        <div class="card" style="background:#0b0d0f;padding:12px;">
          <div class="label">Level income</div>
          <div class="value" id="levelIncome">0.000000 USDT</div>
        </div>
        <div class="card" style="background:#0b0d0f;padding:12px;">
          <div class="label">ROI Pending</div>
          <div class="value" id="roiPending">0.000000 USDT</div>
        </div>
        <div class="card" style="background:#0b0d0f;padding:12px;">
          <div class="label">Total Wallet</div>
          <div class="value" id="totalWallet">0.000000 USDT</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Staking Info</h2>
      <table>
        <tr><td>Staked</td><td id="stakedDisplay">0.000000 USDT</td></tr>
        <tr><td>Target (3x)</td><td id="targetDisplay">0.000000 USDT</td></tr>
        <tr><td>Days to 3x</td><td id="days3x">0 days</td></tr>
        <tr><td>Package Status</td><td id="pkgStatus">Inactive</td></tr>
      </table>
    </div>
    <!-- ===== Progress Bar (3x Target) ===== -->
<div id="progressSection" style="margin-top: 15px;">
  <p style="margin-bottom: 6px; color: #ffcc00; font-weight: bold;">Progress to 3x </p>
  <div style="width:100%; background:#333; border-radius:8px; height:10px; overflow:hidden;">
    <div id="progressFill" style="height:100%; width:0%; background:linear-gradient(90deg,#ffcc00,#00ff99); transition:width 1s;"></div>
  </div>
  <p id="progressLabel" style="margin-top:4px; font-size:13px; color:#aaa;">0% completed</p>
</div>


    <div class="card">
      <h2>Team & Levels</h2>
      <div style="display:flex; gap:12px; align-items:center;">
        <div style="flex:1"><div class="muted">Direct</div><div class="value" id="directCount">0</div></div>
        <div style="flex:1"><div class="muted">Indirect</div><div class="value" id="indirectCount">0</div></div>
        <div style="flex:2"><div class="muted">Active / Inactive</div><div class="value" id="activeCounts">0 / 0</div></div>
      </div>

      <div style="margin-top:12px">
        <table>
          <thead><tr><th>Level</th><th>Percent</th><th>Status</th></tr></thead>
          <tbody id="levelsTbody">
            <tr><td>L1</td><td>10%</td><td id="sL1">Pending</td></tr>
            <tr><td>L2</td><td>10%</td><td id="sL2">Pending</td></tr>
            <tr><td>L3</td><td>5%</td><td id="sL3">Pending</td></tr>
            <tr><td>L4</td><td>3%</td><td id="sL4">Pending</td></tr>
            <tr><td>L5</td><td>2%</td><td id="sL5">Pending</td></tr>
            <tr><td>L6</td><td>1%</td><td id="sL6">Pending</td></tr>
            <tr><td>L7</td><td>1%</td><td id="sL7">Pending</td></tr>
            <tr><td>L8</td><td>1%</td><td id="sL8">Pending</td></tr>
            <tr><td>L9</td><td>1%</td><td id="sL9">Pending</td></tr>
            <tr><td>L10</td><td>1%</td><td id="sL10">Pending</td></tr>
          </tbody>
        </table>
      </div>
    </div>

  </div>
</main>
<div class="card">
  <h3>Withdrawal History (Requests & Approved)</h3>
  <div class="history-table">
    <table id="withdrawHistory">
      <thead><tr><th>When</th><th>Amount</th><th>Approved</th><th>TX</th></tr></thead>
      <tbody id="withdrawHistoryBody"><tr><td colspan="4" class="center muted">No history yet.</td></tr></tbody>
    </table>
  </div>
</div>

<!-- üß© DISCLAIMER SECTION -->
<footer id="disclaimer" style="margin-top:60px;padding:25px 12px;text-align:center;background:rgba(255,255,255,0.03);border-top:1px solid rgba(255,255,255,0.07);font-size:14px;line-height:1.6;color:#bbb;backdrop-filter:blur(8px);">
  <div style="max-width:900px;margin:auto;">
    <h3 style="color:#fff;font-size:16px;margin-bottom:8px;">‚ö†Ô∏è Disclaimer</h3>
    <p>
      This decentralized application (DApp) operates entirely on blockchain smart contracts.
      The platform team does <strong>not control or guarantee</strong> returns, profits, or user funds.
      All staking, deposits, and withdrawals are processed automatically by the verified smart contract.
    </p>
    <p>
      Users are advised to <strong>do their own research (DYOR)</strong> before investing or interacting with any smart contract.
      Cryptocurrency investments are subject to market risk, smart contract vulnerabilities, and potential loss of funds.
    </p>
    <p style="margin-top:10px;">
      By using this DApp, you agree that you are participating voluntarily and take full responsibility for your decisions.
    </p>
    <div style="margin-top:14px;font-size:13px;color:#888;">
      &copy; <script>document.write(new Date().getFullYear());</script> USDT Staking dashboard. All rights reserved.
    </div>
  </div>
</footer>
<!-- üß© END DISCLAIMER -->

<footer>Made with ‚ù§Ô∏è ‚Äî Testnet only while testing</footer>

<script>
/* ====== Final patched JS ‚Äî replace ALL previous <script> JS with this block ====== */
/* Config */
const CONFIG = {
  tokenAddress: "0x1a904b37B0d9D6ab755aBDa4656E42F278FC89AA",
  stakingAddress: "0x1413501574d3221782dd75c70985BC0bf8cE3229",
  decimals: 6,
  // RPC used only for reading logs (use BSC testnet RPC or your network RPC)
  rpcURL: "https://data-seed-prebsc-1-s1.binance.org:8545",
  // fromBlock for Registered event scanning (set to contract deploy block to speed up)
  fromBlock: 0
};

/* ====== Minimal extended ABI (added nextWithdrawId + withdrawals) ====== */
const STAKING_ABI = [
  {"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"address","name":"ref","type":"address"}],"name":"stake","outputs":[],"stateMutability":"nonpayable","type":"function"},
  {"inputs":[{"internalType":"address","name":"refUser","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"address","name":"refForRefUser","type":"address"}],"name":"stakeFor","outputs":[],"stateMutability":"nonpayable","type":"function"},
  {"inputs":[{"internalType":"uint256","name":"amt","type":"uint256"}],"name":"requestWithdrawal","outputs":[],"stateMutability":"nonpayable","type":"function"},
  {"inputs":[{"internalType":"address","name":"usr","type":"address"}],"name":"getTimeTo3x","outputs":[{"internalType":"uint256","name":"daysLeft","type":"uint256"}],"stateMutability":"view","type":"function"},
  {"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"users","outputs":[
    {"internalType":"address","name":"referrer","type":"address"},
    {"internalType":"uint256","name":"totalStake","type":"uint256"},
    {"internalType":"uint256","name":"totalWithdrawn","type":"uint256"},
    {"internalType":"uint256","name":"totalEarned","type":"uint256"},
    {"internalType":"uint256","name":"lastRoiUpdate","type":"uint256"},
    {"internalType":"uint256","name":"roiIncome","type":"uint256"},
    {"internalType":"uint256","name":"instantIncome","type":"uint256"},
    {"internalType":"uint256","name":"levelIncome","type":"uint256"},
    {"internalType":"bool","name":"isActive","type":"bool"},
    {"internalType":"bool","name":"isPaused","type":"bool"},
    {"internalType":"uint256","name":"inactiveAt","type":"uint256"}
  ],"stateMutability":"view","type":"function"},
  {"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"registered","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},
  {"inputs":[{"internalType":"address","name":"ref","type":"address"}],"name":"register","outputs":[],"stateMutability":"nonpayable","type":"function"},
  {"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
  {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":true,"internalType":"address","name":"referrer","type":"address"}],"name":"Registered","type":"event"},
  {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Staked","type":"event"},
  {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"id","type":"uint256"}],"name":"WithdrawalRequested","type":"event"},
  // added getters (public vars) used by UI
  {"inputs":[],"name":"nextWithdrawId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
  {"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"withdrawals","outputs":[
    {"internalType":"address","name":"user","type":"address"},
    {"internalType":"uint256","name":"amount","type":"uint256"},
    {"internalType":"bool","name":"approved","type":"bool"},
    {"internalType":"uint256","name":"timestamp","type":"uint256"}
  ],"stateMutability":"view","type":"function"}
];

const TOKEN_ABI = [
  "function decimals() view returns (uint8)",
  "function balanceOf(address) view returns (uint256)",
  "function approve(address,uint256) returns (bool)"
];

/* ====== State ====== */
let provider, signer, account, stakingContract, tokenContract;
let readProvider; // rpc provider for logs

/* ====== Helpers ====== */
const fromUnits = bn => {
  try { return Number(ethers.utils.formatUnits(bn || 0, CONFIG.decimals)); } catch(e){ return 0; }
};
const toFixed = (v, d=6) => Number(v).toLocaleString('en-US',{minimumFractionDigits:d,maximumFractionDigits:d});

/* ====== UI small helpers ====== */
function updateProgressBar(staked, target, earned) {
  try {
    const fill = document.getElementById('progressFill');
    const lbl = document.getElementById('progressLabel');
    if(!fill||!lbl) return;
    const pct = target>0?Math.min(100,(earned/target)*100):0;
    fill.style.width = pct.toFixed(2)+'%';
    lbl.innerText = `${pct.toFixed(2)}% completed`;
  } catch(e){ console.warn(e); }
}

/* ====== Init / Connect ====== */
async function initWithWeb3Provider(tempProv) {
  provider = tempProv;
  signer = provider.getSigner();
  account = await signer.getAddress();
  stakingContract = new ethers.Contract(CONFIG.stakingAddress, STAKING_ABI, signer);
  tokenContract = new ethers.Contract(CONFIG.tokenAddress, TOKEN_ABI, signer);

  // read provider (rpc) for logs (separate)
  readProvider = new ethers.providers.JsonRpcProvider(CONFIG.rpcURL);

  document.getElementById('walletDisplay').innerText = account;
  document.getElementById('refLink').value = `${window.location.origin}${window.location.pathname}?ref=${account}`;

  attachUIHandlers();
  listenEvents();

  localStorage.setItem('staking_connected','1');
  await refreshAll();
}

async function connectWallet() {
  if(!window.ethereum) return alert('MetaMask not found - install it!');
  try {
    await window.ethereum.request({ method: 'eth_requestAccounts' });
    const prov = new ethers.providers.Web3Provider(window.ethereum, 'any');
    await initWithWeb3Provider(prov);
  } catch(e){
    console.error('connect failed', e);
    alert('Connect failed: '+(e.message||e));
  }
}
document.getElementById('connectBtn').addEventListener('click', connectWallet);

/* Auto reconnect */
window.addEventListener('load', async () => {
  try {
    if(window.ethereum) {
      const p = new ethers.providers.Web3Provider(window.ethereum,'any');
      const accs = await p.listAccounts();
      if(accs && accs.length>0) {
        await initWithWeb3Provider(p);
        console.log('Auto reconnect OK');
        return;
      }
    }
    if(localStorage.getItem('staking_connected')) {
      if(window.ethereum) {
        const p = new ethers.providers.Web3Provider(window.ethereum,'any');
        const accs = await p.listAccounts();
        if(accs && accs.length>0) await initWithWeb3Provider(p);
      }
    }
  } catch(e){ console.warn('Auto reconnect error', e); }
});

/* ====== UI Handlers (one-time) ====== */
let attached=false;
function attachUIHandlers(){
  if(attached) return; attached=true;

  document.getElementById('approveBtn').onclick = async () => {
    if(!tokenContract) return alert('Connect wallet first');
    try {
      const tx = await tokenContract.approve(CONFIG.stakingAddress, ethers.constants.MaxUint256);
      await tx.wait();
      alert('Approved ‚úî');
      await refreshAll();
    } catch(e){ console.error(e); alert('Approve failed: '+(e.message||e)); }
  };

  document.getElementById('stakeBtn').onclick = async () => {
    if(!stakingContract) return alert('Connect wallet first');
    try {
      const amt = document.getElementById('stakeAmt').value;
      if(!amt || Number(amt) < 20) return alert('Min 20 USDT');
      const refParam = new URLSearchParams(window.location.search).get('ref') || ethers.constants.AddressZero;
      const units = ethers.utils.parseUnits(String(amt), CONFIG.decimals);
      const tx = await stakingContract.stake(units, refParam || ethers.constants.AddressZero);
      await tx.wait();
      alert('Stake successful ‚úî');
      await refreshAll();
    } catch(e){ console.error(e); alert('Stake failed: '+(e.message||e)); }
  };

  document.getElementById('stakeForBtn').onclick = async () => {
    if(!stakingContract) return alert('Connect wallet first');
    try {
      const amt = document.getElementById('p2pAmount').value;
      const addr = document.getElementById('p2pAddress').value;
      if(!amt || Number(amt)<20) return alert('Min 20');
      if(!addr || !ethers.utils.isAddress(addr)) return alert('Invalid address');
      const owner = await stakingContract.owner();
      const units = ethers.utils.parseUnits(String(amt), CONFIG.decimals);
      const tx = await stakingContract.stakeFor(addr, units, owner);
      await tx.wait();
      alert('P2P stake successful ‚úî');
      // refresh so balances show correctly (wallet token balance changed onchain)
      await refreshAll();
    } catch(e){ console.error(e); alert('P2P failed: '+(e.message||e)); }
  };

  document.getElementById('requestWithdraw').onclick = async () => {
    if(!stakingContract) return alert('Connect wallet first');
    try {
      const amt = document.getElementById('withdrawAmt').value;
      if(!amt || Number(amt)<20) return alert('Min 20');
      const units = ethers.utils.parseUnits(String(amt), CONFIG.decimals);
      const tx = await stakingContract.requestWithdrawal(units);
      await tx.wait();
      document.getElementById('withdrawStatus').innerText = 'Withdraw requested ‚úî';
      await refreshAll();
    } catch(e){ console.error(e); alert('Withdraw failed: '+(e.message||e)); }
  };

  document.getElementById('copyLink').onclick = async () => {
    const v = document.getElementById('refLink').value;
    if(!v) return alert('No link');
    await navigator.clipboard.writeText(v); alert('Referral copied');
  };

  document.getElementById('showTeam').onclick = async () => {
    await loadTeamInfo();
    alert('Team refreshed (see UI)');
  };

  document.getElementById('refreshBtn').onclick = refreshAll;
}

/* ====== Contract event listeners (on-chain updates) ====== */
function listenEvents(){
  if(!stakingContract) return;
  try {
    stakingContract.removeAllListeners && stakingContract.removeAllListeners();

    stakingContract.on('Staked', (user, from, amount) => {
      console.log('Event Staked', user, from, amount.toString());
      refreshAll().catch(()=>{});
    });

    stakingContract.on('Registered', (user, referrer) => {
      console.log('Event Registered', user, referrer);
      // small delay to ensure logs available via readProvider
      setTimeout(()=>{ loadTeamInfo().catch(()=>{}); }, 800);
    });

    stakingContract.on('WithdrawalRequested', (user, id) => {
      console.log('Event WithdrawalRequested', user, id.toString());
      refreshAll().catch(()=>{});
    });

  } catch(e){ console.warn('listenEvents err', e); }
}

/* ====== ROI read-only from chain (no per-second live) ====== */
async function forceUpdateROI() {
  if(!stakingContract || !account) return 0;
  try {
    const info = await stakingContract.users(account);
    const roi = fromUnits(info.roiIncome || info[5] || 0);
    const el = document.getElementById('roiPending');
    if(el) el.innerText = `${toFixed(roi,6)} USDT`;
    return roi;
  } catch(e){ console.warn('forceUpdateROI err', e); return 0; }
}

/* ====== Team: read Registered events via readProvider, build BFS levels up to 10 ====== */
async function getTeamFromEvents(rootAccount) {
  try {
    if(!readProvider) readProvider = new ethers.providers.JsonRpcProvider(CONFIG.rpcURL);
    const iface = new ethers.utils.Interface(STAKING_ABI);
    const topic = iface.getEventTopic('Registered(address,address)');

    const logs = await readProvider.getLogs({
      fromBlock: CONFIG.fromBlock || 0,
      toBlock: 'latest',
      address: CONFIG.stakingAddress,
      topics: [topic]
    });

    // build map of ref -> set(children)
    const children = new Map();
    for(const lg of logs) {
      try {
        const parsed = iface.parseLog(lg);
        const user = String(parsed.args.user).toLowerCase();
        const ref = String(parsed.args.referrer).toLowerCase();
        if(!children.has(ref)) children.set(ref, new Set());
        children.get(ref).add(user);
      } catch(e){ continue; }
    }

    // BFS levels up to 10
    const root = rootAccount.toLowerCase();
    const maxLevels = 10;
    const levels = [];
    const seen = new Set();

    const l1 = children.has(root) ? Array.from(children.get(root)) : [];
    levels.push(l1);
    l1.forEach(x=>seen.add(x));

    for(let lvl=2; lvl<=maxLevels; lvl++){
      const prev = levels[lvl-2] || [];
      if(prev.length===0){ levels.push([]); continue; }
      const thisLevel = [];
      for(const parent of prev){
        const kids = children.get(parent) ? Array.from(children.get(parent)) : [];
        for(const kid of kids){
          if(kid===root) continue;
          if(!seen.has(kid)){ seen.add(kid); thisLevel.push(kid); }
        }
      }
      levels.push(thisLevel);
    }

    console.log('getTeamFromEvents levels:', levels.map(l=>l.length));
    return { levels };
  } catch(e){
    console.error('getTeamFromEvents error', e);
    return { levels: [] };
  }
}

/* ====== Update Team UI from levels array ====== */
async function updateTeamUI(levels) {
  try {
    const lvlArr = levels || [];
    const directList = lvlArr[0] || [];
    const indirectList = [].concat(...(lvlArr.slice(1)));
    const directCount = directList.length;
    const indirectCount = indirectList.length;

    let active=0, inactive=0;
    const combined = [...directList, ...indirectList];

    for(const addr of combined){
      try {
        const info = await stakingContract.users(addr).catch(()=>null);
        if(!info){ active++; continue; } // assume active if RPC fails
        const st = fromUnits(info.totalStake || info[1] || 0);
        const isAct = (info.isActive === true) || (st > 0);
        if(isAct) active++; else inactive++;
      } catch(e){ console.warn('updateTeamUI user fetch err', addr, e); active++; }
    }

    // update DOM
    const directEl = document.getElementById('directCount');
    const indirectEl = document.getElementById('indirectCount');
    const activeEl = document.getElementById('activeCounts');
    if(directEl) directEl.innerText = directCount;
    if(indirectEl) indirectEl.innerText = indirectCount;
    if(activeEl) activeEl.innerText = `${active} / ${inactive}`;

    // level rows: open based on directCount (L1 opens if at least 1 direct, L2 if at least 2 directs ... classic rule)
    const rows = document.querySelectorAll('#levelsTbody tr');
    rows.forEach((r,i)=>{
      const cell = r.querySelector('td:last-child');
      if(!cell) return;
      if(i < Math.min(directCount, 10)){ cell.innerText='Open ‚úÖ'; cell.style.color='#00FF90'; cell.style.fontWeight='600'; }
      else { cell.innerText='Pending'; cell.style.color=''; cell.style.fontWeight=''; }
    });

    console.log(`Team UI updated ‚Äî directs:${directCount} indirects:${indirectCount} active:${active} inactive:${inactive}`);
  } catch(e){ console.error('updateTeamUI err', e); }
}

/* ====== loadTeamInfo wrapper: tries onchain logs, then cache, then fallback ====== */
async function loadTeamInfo(){
  try {
    if(!stakingContract || !account) return;
    console.log('Loading team via logs...');
    // try read from events
    try {
      const { levels } = await getTeamFromEvents(account);
      // store cache
      try{ localStorage.setItem('team_levels_'+account.toLowerCase(), JSON.stringify(levels)); }catch(e){}
      await updateTeamUI(levels);
      // attach Registered listener once to auto update levels
      if(!window._teamListener) {
        window._teamListener = true;
        try{
          stakingContract.on('Registered', async (user, ref) => {
            setTimeout(async ()=> {
              try {
                const { levels: newLv } = await getTeamFromEvents(account);
                localStorage.setItem('team_levels_'+account.toLowerCase(), JSON.stringify(newLv));
                await updateTeamUI(newLv);
              } catch(e){ console.warn('Registered handler err', e); }
            }, 600);
          });
        } catch(e){ console.warn('could not attach Registered listener', e); }
      }
      return;
    } catch(err){
      console.warn('Reading team from logs failed', err);
    }

    // fallback: local cache
    try {
      const raw = localStorage.getItem('team_levels_' + account.toLowerCase());
      if(raw) { const cached = JSON.parse(raw); if(cached && cached.length){ await updateTeamUI(cached); return; } }
    } catch(e){ console.warn('team cache read error', e); }

    // final fallback: empty
    await updateTeamUI([]);
  } catch(e){ console.error('loadTeamInfo err', e); }
}

/* ====== Withdraw history (uses nextWithdrawId + withdrawals getter) ====== */
async function loadWithdrawHistory(){
  const tb = document.getElementById('withdrawHistoryBody');
  if(!tb) return;
  tb.innerHTML = '<tr><td colspan="4" class="center muted">Loading...</td></tr>';
  try {
    if(!stakingContract) { tb.innerHTML='<tr><td colspan="4">Contract not connected</td></tr>'; return; }
    const nextIdBN = await stakingContract.nextWithdrawId().catch(()=>0);
    const nextId = Number(nextIdBN || 0);
    let html = '';
    for(let i = nextId - 1; i >= 1; i--) {
      const w = await stakingContract.withdrawals(i).catch(()=>null);
      if(!w || !w.user) continue;
      if(String(w.user).toLowerCase() !== account.toLowerCase()) continue;
      const when = new Date(Number(w.timestamp)*1000).toLocaleString();
      const amt = fromUnits(w.amount || 0);
      const status = w.approved ? '‚úÖ Approved' : '‚è≥ Pending';
      html += `<tr><td>${when}</td><td>${toFixed(amt,2)} USDT</td><td>${status}</td><td>${i}</td></tr>`;
    }
    tb.innerHTML = html || '<tr><td colspan="4" class="center muted">No history</td></tr>';
  } catch(e){
    console.error('loadWithdrawHistory err', e);
    tb.innerHTML = '<tr><td colspan="4" class="center muted">Error loading history</td></tr>';
  }
}

/* ====== Main refresh: balances, ROI, team, withdraws, progress ====== */
async function refreshAll(){
  if(!stakingContract || !account) return;
  try {
    // token balance
    const rawBal = await tokenContract.balanceOf(account).catch(()=>0);
    const bal = fromUnits(rawBal);
    document.getElementById('walletDisplay').innerText = `${account} ‚Äî ${toFixed(bal,4)} USDT`;

    // onchain user info
    const info = await stakingContract.users(account);
    const staked = fromUnits(info.totalStake || 0);
    const roiOnChain = fromUnits(info.roiIncome || 0);
    const inst = fromUnits(info.instantIncome || 0);
    const lvl = fromUnits(info.levelIncome || 0);
    const earned = fromUnits(info.totalEarned || 0);
    const totalWallet = roiOnChain + inst + lvl;

    document.getElementById('stakedDisplay').innerText = `${toFixed(staked,6)} USDT`;
    document.getElementById('targetDisplay').innerText = `${toFixed(staked*3,6)} USDT`;
    document.getElementById('roiPending').innerText = `${toFixed(roiOnChain,6)} USDT`;
    document.getElementById('instantIncome').innerText = `${toFixed(inst,6)} USDT`;
    document.getElementById('levelIncome').innerText = `${toFixed(lvl,6)} USDT`;
    document.getElementById('totalWallet').innerText = `${toFixed(totalWallet,6)} USDT`;
    document.getElementById('pkgStatus').innerText = (info.isActive ? '‚úÖ Active' : 'Inactive');

    // days to 3x
    try {
      const d = await stakingContract.getTimeTo3x(account).catch(()=>0);
      document.getElementById('days3x').innerText = `${Number(d) || 0} days`;
    } catch(e){ document.getElementById('days3x').innerText = 'N/A'; }

    // progress bar uses totalEarned vs stake*3
    updateProgressBar(staked, staked*3, earned);

    // load team and withdraw history (non-blocking)
    loadTeamInfo().catch(()=>{});
    loadWithdrawHistory().catch(()=>{});

  } catch(e){
    console.error('refreshAll err', e);
  }
}

/* ====== Chain listeners for wallet/chain changes ====== */
if(window.ethereum){
  window.ethereum.on('accountsChanged', (accs) => {
    if(!accs || accs.length===0){ document.getElementById('walletDisplay').innerText='Not connected'; localStorage.removeItem('staking_connected'); }
    else location.reload();
  });
  window.ethereum.on('chainChanged', ()=>location.reload());
}

/* ====== Final log ====== */
console.log('Patched JS loaded ‚Äî ROI from chain only, team via events, withdraw history ok.');

/* ====== Utility toFixed used in history ====== */
function toFixed(v,d=2){ return Number(v).toLocaleString('en-US',{minimumFractionDigits:d,maximumFractionDigits:d}); }
</script>


