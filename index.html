<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>USDT Staking â€” Dashboard (Live)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<!-- ethers v5 UMD -->
<head>
  <meta charset="utf-8" />
  <title>ðŸš€ USDT Staking â€” Dashboard</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  
  <!-- âœ… Correct ethers.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>

  <style>
    /* tumhara CSS */
  </style>
</head>
<style>
  :root{
    --bg:#0f0f10; --card:#161616; --muted:#9a9a9a; --accent:#ffd000; --accent-dark:#e6c800;
    --txt:#f1f1f1; --danger:#c0392b;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  html,body{height:100%; margin:0; background:linear-gradient(180deg,#080808 0%, #0f0f10 100%); color:var(--txt);}
  header{display:flex;align-items:center;justify-content:space-between;padding:20px 36px;border-bottom:1px solid rgba(255,255,255,0.03)}
  h1{margin:0;font-size:20px;color:var(--accent)}
  .connectBtn{background:var(--accent);border:none;padding:10px 16px;border-radius:10px;font-weight:600;cursor:pointer}
  .container{max-width:1100px;margin:28px auto;padding:0 20px}
  .card{background:var(--card);padding:18px;border-radius:12px;margin-bottom:18px;box-shadow:0 6px 18px rgba(0,0,0,0.5)}
  input[type="text"], input[type="number"]{width:70%;padding:10px;border-radius:8px;border:none;background:#0d0d0d;color:var(--txt);margin-right:10px}
  .row{display:flex;gap:14px;align-items:center;flex-wrap:wrap}
  .btn{background:var(--accent);border:none;padding:10px 14px;border-radius:10px;cursor:pointer;font-weight:700}
  .btn.gray{background:#222;color:var(--txt)}
  .grid3{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
  .incomeBox{background:#0d0d0d;border-radius:10px;padding:14px;text-align:left}
  small{color:var(--muted)}
  table{width:100%;border-collapse:collapse;margin-top:12px}
  th,td{border:1px solid rgba(255,255,255,0.04);padding:8px;text-align:left}
  th{background:#111;color:var(--accent)}
  .muted{color:var(--muted)}
  .danger{background:var(--danger);color:#fff;padding:8px;border-radius:8px;border:none}
  .flex-space{display:flex;justify-content:space-between;align-items:center}
</style>
</head>
<body>

<header>
  <h1>ðŸš€ USDT Staking â€” Dashboard</h1>
  <div>
    <button id="connectBtn" class="connectBtn">Connect Wallet</button>
  </div>
</header>

<div class="container">

  <!-- STAKE -->
  <div class="card">
    <div class="flex-space">
      <div><strong>Stake USDT</strong><br><small class="muted">Minimum 20 USDT â€” multiples of 20</small></div>
      <div id="walletInfo" class="muted">Wallet: not connected</div>
    </div>
    <div style="margin-top:12px" class="row">
      <input id="stakeAmount" type="number" placeholder="Amount (USDT) - min 20 multiples of 20" />
      <button class="btn gray" id="quickApprove">Quick Approve</button>
      <button class="btn" id="stakeBtn">Stake</button>
    </div>
  </div>

  <!-- REFERRAL -->
  <div class="card">
    <strong>Your referral link</strong>
    <div style="margin-top:10px" class="row">
      <input id="refInput" type="text" readonly />
      <button class="btn gray" id="copyRefBtn">Copy</button>
    </div>
    <small class="muted">Share this link â€” only users who join using a referral link will be accepted (if contract enforces it).</small>
  </div>

  <!-- INCOME BOXES -->
  <div class="card">
    <div class="grid3">
      <div class="incomeBox">
        <small>Instant income</small><br><strong id="instantIncome">0 USDT</strong>
      </div>
      <div class="incomeBox">
        <small>Level income</small><br><strong id="levelIncome">0 USDT</strong>
      </div>
      <div class="incomeBox">
        <small>ROI income (accrued)</small><br><strong id="roiIncome">0 USDT</strong>
      </div>
    </div>
  </div>

  <!-- WITHDRAW -->
  <div class="card">
    <strong>Withdraw</strong>
    <div style="margin-top:12px" class="row">
      <input id="withdrawAmount" type="number" placeholder="Amount (min 10, multiples of 10)" />
      <button class="btn" id="requestWithdrawBtn">Request Withdraw</button>
    </div>
    <div id="withdrawHistory" style="margin-top:12px">
      <small class="muted">Withdrawal history will appear here (from contract's Withdraw events).</small>
    </div>
  </div>

  <!-- STAKING INFO / TEAM -->
  <div class="card">
    <div class="grid3">
      <div style="padding-right:12px">
        <strong>Staking Info</strong>
        <div style="margin-top:8px">
          Staked: <span id="staked">0</span> USDT<br>
          Target (3x): <span id="target3x">0</span> USDT<br>
          Package Status: <span id="packageStatus">Inactive</span>
        </div>
      </div>
      <div>
        <strong>Team Info</strong>
        <div style="margin-top:8px">
          Direct: <span id="directCount">0</span><br>
          Indirect: <span id="indirectCount">0</span><br>
        </div>
      </div>
      <div>
        <strong>Quick actions</strong>
        <div style="margin-top:8px" class="row">
          <button class="btn gray" id="checkPendingBtn">Check Pending</button>
          <!-- claim button removed as requested -->
        </div>
      </div>
    </div>
  </div>

  <!-- TEAM & LEVELS -->
  <div class="card">
    <strong>Direct referrals</strong>
    <div id="directList" style="margin-top:8px" class="muted">No directs yet.</div>

    <hr style="border-color:rgba(255,255,255,0.03);margin:12px 0">

    <strong>Indirect referrals</strong>
    <div id="indirectList" style="margin-top:8px" class="muted">No indirects yet.</div>

    <hr style="border-color:rgba(255,255,255,0.03);margin:12px 0">

    <strong>Level structure</strong>
    <table>
      <thead><tr><th>Level</th><th>Percent</th><th>Status</th></tr></thead>
      <tbody id="levelsTable">
        <!-- filled by JS -->
      </tbody>
    </table>
  </div>

</div>

<script>
/* ========== CONFIG ========== */
const STAKING_ADDRESS = "0x3aF2c75A4723b2139EB803bf5d558e7d43991D6E";
const TOKEN_ADDRESS   = "0xEbA5032Be8fc2d2a2fa29e134853ab6aAA12fa1C";

/* Minimal token ABI (ERC20-like) */
const tokenAbi = [
  "function decimals() view returns (uint8)",
  "function allowance(address owner, address spender) view returns (uint256)",
  "function approve(address spender, uint256 amount) returns (bool)",
  "function balanceOf(address) view returns (uint256)",
  "function transfer(address to, uint256 amount) returns (bool)",
  "function transferFrom(address from, address to, uint256 amount) returns (bool)",
];

/* Minimal staking ABI: functions + events we use */
const stakingAbi = [
  "function deposit(uint256 amount, address referrer) external",
  "function withdrawPrincipal(uint256 amount) external",
  "function pendingRewards(address user) view returns (uint256)",
  "function getUserInfo(address user) external view returns (uint256 staked,uint256 lastAction,address referrer,uint256 totalEarned,uint256 pending)",
  "event Deposit(address indexed user,uint256 amount,address referrer)",
  "event Claim(address indexed user,uint256 reward)",
  "event Withdraw(address indexed user,uint256 amount)",
  "event ParamsUpdated(uint256 roiBP,uint256 lockSeconds,uint256 minTx,uint256 capX)"
];

/* ========== GLOBALS ========== */
let provider, signer, account;
let tokenContract, stakingContract;
let tokenDecimals = 6; // default to USDT-like, will fetch on connect
let ifaceStaking;

/* UI references */
const connectBtn = document.getElementById("connectBtn");
const walletInfo = document.getElementById("walletInfo");
const refInput = document.getElementById("refInput");
const copyRefBtn = document.getElementById("copyRefBtn");
const quickApproveBtn = document.getElementById("quickApprove");
const stakeBtn = document.getElementById("stakeBtn");
const stakeAmountInput = document.getElementById("stakeAmount");
const instantIncomeEl = document.getElementById("instantIncome");
const levelIncomeEl = document.getElementById("levelIncome");
const roiIncomeEl = document.getElementById("roiIncome");
const stakedEl = document.getElementById("staked");
const target3xEl = document.getElementById("target3x");
const packageStatusEl = document.getElementById("packageStatus");
const directCountEl = document.getElementById("directCount");
const indirectCountEl = document.getElementById("indirectCount");
const directListEl = document.getElementById("directList");
const indirectListEl = document.getElementById("indirectList");
const withdrawHistoryEl = document.getElementById("withdrawHistory");
const withdrawAmountInput = document.getElementById("withdrawAmount");
const requestWithdrawBtn = document.getElementById("requestWithdrawBtn");
const checkPendingBtn = document.getElementById("checkPendingBtn");
const levelsTable = document.getElementById("levelsTable");

/* standard level percents (10 levels) */
const levelPercents = [10,10,5,3,2,1,1,1,1,1];

/* fill level table */
(function fillLevelTable(){
  levelsTable.innerHTML = "";
  for(let i=0;i<10;i++){
    const tr = document.createElement("tr");
    tr.innerHTML = `<td>L${i+1}</td><td>${levelPercents[i]}%</td><td id="lvl${i+1}">Pending</td>`;
    levelsTable.appendChild(tr);
  }
})();

/* ========== CONNECT ========== */
async function connectWallet(){
  try{
    if(!window.ethereum) throw new Error("No injected wallet (MetaMask) found");
    provider = new ethers.providers.Web3Provider(window.ethereum, "any");
    await provider.send("eth_requestAccounts", []);
    signer = provider.getSigner();
    account = await signer.getAddress();
    walletInfo.innerText = "Wallet: " + account;
    connectBtn.innerText = account.slice(0,6) + "..." + account.slice(-4);
    tokenContract = new ethers.Contract(TOKEN_ADDRESS, tokenAbi, signer);
    stakingContract = new ethers.Contract(STAKING_ADDRESS, stakingAbi, signer);
    ifaceStaking = new ethers.utils.Interface(stakingAbi);

    // fetch token decimals
    try { tokenDecimals = await tokenContract.decimals(); } catch(e){ tokenDecimals = 6; }

    // set referral link
    const base = window.location.origin + window.location.pathname;
    refInput.value = `${base}?ref=${account}`;

    // load initial data & events
    await refreshAll();
    subscribeToEvents();
  }catch(err){
    alert("Wallet connection failed: " + (err && err.message ? err.message : String(err)));
  }
}

connectBtn.addEventListener("click", connectWallet);

/* ========== SUBSCRIBE EVENTS (real-time) ========== */
function subscribeToEvents(){
  try{
    // deposit
    stakingContract.on("Deposit", (user, amount, referrer, ev)=>{
      // update UI
      const amountHuman = formatUnits(amount);
      if(user.toLowerCase() === account.toLowerCase()){
        // our deposit happened: refresh balances
        refreshUserInfo();
      }
      // add to team lists if referrer == our account
      if(referrer && referrer.toLowerCase() === account.toLowerCase()){
        appendDirect(user, amountHuman);
      }
      // also refresh totals
      fetchTotals();
    });

    // withdraw
    stakingContract.on("Withdraw", (user, amount, ev)=>{
      if(user.toLowerCase() === account.toLowerCase()){
        refreshUserInfo();
      }
      appendWithdrawEvent(user, amount);
      fetchTotals();
    });

    // claim (we don't have claim button, but listen)
    stakingContract.on("Claim", (user, reward, ev)=>{
      if(user.toLowerCase() === account.toLowerCase()){
        refreshUserInfo();
      }
      fetchTotals();
    });

    // params update
    stakingContract.on("ParamsUpdated", (roiBP, lockSeconds, minTx, capX)=>{
      fetchTotals();
    });

  }catch(e){
    console.warn("subscribeToEvents error", e);
  }
}

/* ========== HELPERS ========== */
function parseUnits(num){ // human USDT -> contract units (6 decimals)
  return ethers.utils.parseUnits(String(num), tokenDecimals);
}
function formatUnits(bigNum){ // contract units -> human string
  try { return Number(ethers.utils.formatUnits(bigNum, tokenDecimals)); } catch(e){ return 0; }
}
function shortAddr(a){ return a ? a.slice(0,6)+"..."+a.slice(-4) : a; }

/* ========== UI UPDATERS & STORAGE FOR SESSION ========== */
let directRefs = []; // session-built from logs
let indirectRefs = [];
let withdrawHistory = [];

function appendDirect(user, amount){
  directRefs.push({user,amount});
  renderTeam();
}
function appendIndirect(user, amount){
  indirectRefs.push({user,amount});
  renderTeam();
}
function appendWithdrawEvent(user, amount){
  withdrawHistory.unshift({user, amount: formatUnits(amount), time: new Date().toLocaleString()});
  renderWithdrawHistory();
}

function renderTeam(){
  directCountEl.innerText = directRefs.length;
  indirectCountEl.innerText = indirectRefs.length;
  directListEl.innerHTML = directRefs.length ? directRefs.map(x=>`<div>${shortAddr(x.user)} â€” ${x.amount} USDT</div>`).join("") : "No directs yet.";
  indirectListEl.innerHTML = indirectRefs.length ? indirectRefs.map(x=>`<div>${shortAddr(x.user)} â€” ${x.amount} USDT</div>`).join("") : "No indirects yet.";
}

function renderWithdrawHistory(){
  if(!withdrawHistory.length){
    withdrawHistoryEl.innerHTML = `<small class="muted">No withdrawals yet.</small>`;
    return;
  }
  withdrawHistoryEl.innerHTML = `<table><thead><tr><th>When</th><th>Who</th><th>Amount</th></tr></thead><tbody>${withdrawHistory.map(w=>`<tr><td>${w.time}</td><td>${shortAddr(w.user)}</td><td>${w.amount} USDT</td></tr>`).join("")}</tbody></table>`;
}

/* ========== READ ON-CHAIN / PAST EVENTS (simple indexing) ========== */
async function fetchPastEventsForAccount(){
  // read Deposit/Withdraw logs for this contract and build directs/indirects/withdraw history
  if(!provider || !account) return;
  const network = await provider.getNetwork();
  const fromBlock = 0; // caution: set to your known deployment block for production to speed up
  const toBlock = "latest";

  // prepare filters via interface signature
  const depositTopic = ifaceStaking.getEventTopic("Deposit");
  const withdrawTopic = ifaceStaking.getEventTopic("Withdraw");

  // fetch deposit logs (may be heavy on mainnet - set fromBlock appropriately)
  try{
    const depositLogs = await provider.getLogs({address: STAKING_ADDRESS, fromBlock, toBlock, topics:[depositTopic]});
    directRefs = [];
    indirectRefs = [];
    for(const log of depositLogs){
      const parsed = ifaceStaking.parseLog(log);
      const user = parsed.args.user;
      const amount = parsed.args.amount;
      const referrer = parsed.args.referrer;
      if(referrer && referrer.toLowerCase() === account.toLowerCase()){
        directRefs.push({user, amount: formatUnits(amount)});
      } else {
        // if the deposit's referrer chain includes the account? hard to know without full graph -> we skip
      }
    }
  }catch(e){ console.warn("fetch deposit logs err", e); }

  // fetch withdraw logs for history
  try{
    const withdrawLogs = await provider.getLogs({address: STAKING_ADDRESS, fromBlock, toBlock, topics:[withdrawTopic]});
    withdrawHistory = [];
    for(const log of withdrawLogs){
      const parsed = ifaceStaking.parseLog(log);
      const user = parsed.args.user;
      const amount = parsed.args.amount;
      if(user && (user.toLowerCase() === account.toLowerCase())){
        withdrawHistory.push({user, amount: formatUnits(amount), time: (new Date()).toLocaleString()});
      } else {
        // we keep others as well if you want
      }
    }
  }catch(e){ console.warn("fetch withdraw logs err", e); }

  renderTeam();
  renderWithdrawHistory();
}

/* ========== ACTIONS ========== */
async function quickApprove(){
  if(!tokenContract) return alert("Connect wallet first");
  try{
    const max = ethers.constants.MaxUint256;
    const tx = await tokenContract.approve(STAKING_ADDRESS, max);
    await tx.wait();
    alert("Quick approve confirmed");
  }catch(e){ alert("Approve failed: "+ (e && e.message ? e.message : e)); }
}
quickApproveBtn.addEventListener("click", quickApprove);

async function stake(){
  if(!stakingContract || !tokenContract) return alert("Connect wallet first");
  const v = Number(stakeAmountInput.value);
  if(!v || v < 20 || (v % 20 !== 0)) return alert("Amount must be >=20 and multiples of 20");
  const amountUnits = parseUnits(v);
  try{
    // check allowance & auto-approve small case
    const allowance = await tokenContract.allowance(account, STAKING_ADDRESS);
    if(allowance.lt(amountUnits)){
      // request approve then deposit after approval confirmed
      const approveTx = await tokenContract.approve(STAKING_ADDRESS, ethers.constants.MaxUint256);
      await approveTx.wait();
    }
    const tx = await stakingContract.deposit(amountUnits, ethers.constants.AddressZero); // using zero ref (or parse URL ref if you want)
    await tx.wait();
    alert("Stake transaction confirmed");
    await refreshUserInfo();
    await fetchTotals();
  }catch(e){
    alert("Stake failed: " + (e && e.data && e.data.message ? e.data.message : (e && e.message ? e.message : e)));
    console.error(e);
  }
}
stakeBtn.addEventListener("click", stake);

async function requestWithdraw(){
  if(!stakingContract) return alert("Connect wallet first");
  const v = Number(withdrawAmountInput.value);
  if(!v || v < 10 || (v % 10 !== 0)) return alert("Amount must be >=10 and multiples of 10");
  // We call withdrawPrincipal only when lock allows â€” your contract might require admin approval flow.
  try{
    const units = parseUnits(v);
    // Here, to support "approval by admin", you might instead send a withdraw request to a queue contract. This example calls withdrawPrincipal directly.
    const tx = await stakingContract.withdrawPrincipal(units);
    await tx.wait();
    alert("Withdraw executed");
    await refreshUserInfo();
  }catch(e){
    alert("Withdraw failed: " + (e && e.data && e.data.message ? e.data.message : (e && e.message ? e.message : e)));
    console.error(e);
  }
}
requestWithdrawBtn.addEventListener("click", requestWithdraw);

/* check pending rewards and update ROI box */
async function checkPending(){
  if(!stakingContract) return;
  try{
    const pending = await stakingContract.pendingRewards(account);
    roiIncomeEl.innerText = Number(ethers.utils.formatUnits(pending, tokenDecimals)).toFixed(6) + " USDT";
    alert("Pending rewards refreshed");
  }catch(e){ console.warn(e); alert("Failed to check pending: "+(e && e.message ? e.message : e)); }
}
checkPendingBtn.addEventListener("click", checkPending);

/* ========== REFRESHERS ========== */
async function refreshUserInfo(){
  try{
    if(!stakingContract || !account) return;
    const ui = await stakingContract.getUserInfo(account);
    const stakedUnits = ui[0];
    const pending = ui[4];
    const stakedHuman = formatUnits(stakedUnits);
    stakedEl.innerText = stakedHuman;
    target3xEl.innerText = (stakedHuman * 3).toFixed(6);
    packageStatusEl.innerText = (stakedHuman>0 ? "Active":"Inactive");
    roiIncomeEl.innerText = Number(formatUnits(pending)).toFixed(6) + " USDT";
    // instant & level incomes are contract-specific; here we display totalEarned as 'instant' for demo
    const totalEarned = formatUnits(ui[3]);
    instantIncomeEl.innerText = Number(totalEarned).toFixed(6) + " USDT";
    // level income not exposed in this contract by default â€” keep 0 or compute if contract exposes it
    levelIncomeEl.innerText = "0 USDT";
  }catch(e){ console.warn("refreshUserInfo err", e); }
}

async function fetchTotals(){
  // If your contract exposes totalStaked/totalRewards, add calls here. We'll just refresh user info & logs
  await fetchPastEventsForAccount();
  await refreshUserInfo();
}

/* convenience: run refreshAll */
async function refreshAll(){
  if(!account) return;
  await fetchTotals();
}

/* parse URL ref param (prefill deposit ref) */
function initFromUrl(){
  try{
    const params = new URLSearchParams(window.location.search);
    const ref = params.get("ref");
    if(ref){
      // prefill referral input showing what ref came in
      // If user connects, deposit code should use this ref as second arg to deposit()
      // We'll show it in referral input only if not connected, and keep original ref if connected
      refInput.value = window.location.origin + window.location.pathname + "?ref="+ref;
    }
  }catch(e){}
}
initFromUrl();

/* copy referral */
copyRefBtn.addEventListener("click", function(){
  refInput.select();
  document.execCommand("copy");
  alert("Referral link copied");
});

/* auto refresh every 60s */
setInterval(()=>{ if(account) refreshAll(); }, 60_000);

</script>

</body>
</html>
