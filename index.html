<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Full Staking DApp ‚Äî Dashboard</title>

  <!-- ethers v5 -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>

  <style>
    :root{
      --bg:#0b0d0f; --card:#0f1214; --muted:#9aa4b2; --accent:#ffd86b;
      --panel:#121416; --success:#00c176; --danger:#ff6b6b;
    }
    body{margin:0;font-family:Inter,Arial,sans-serif;background:var(--bg);color:#e6eef6;}
    header{padding:18px 24px;text-align:center;background:linear-gradient(90deg,#081018,#0d1016);box-shadow:0 2px 8px rgba(0,0,0,0.5);}
    header h1{margin:0;color:var(--accent);font-size:20px;}
    .topbar{display:flex;justify-content:flex-end;gap:12px;padding:12px 24px;align-items:center;max-width:1180px;margin:0 auto;}
    .wallet-btn{background:var(--accent);color:#000;padding:8px 14px;border-radius:8px;border:0;font-weight:600;cursor:pointer;}
    .container{padding:20px;display:grid;grid-template-columns:360px 1fr;gap:18px;max-width:1180px;margin:18px auto;}
    .left{display:flex;flex-direction:column;gap:14px;}
    .card{background:var(--card);border-radius:12px;padding:14px;box-shadow:0 6px 20px rgba(0,0,0,0.4);}
    .card h2{margin:0 0 10px 0;color:var(--accent);font-size:16px;}
    .muted{color:var(--muted);font-size:13px;}
    input, textarea{width:100%;padding:10px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:var(--panel);color:#fff;box-sizing:border-box;}
    .small-btn{padding:10px 12px;border-radius:8px;border:0;background:#2a2f35;color:#fff;cursor:pointer;margin-top:8px;}
    .accent-btn{background:var(--accent);color:#000;border:0;padding:10px 12px;border-radius:8px;cursor:pointer;font-weight:700;margin-top:8px;}
    .right{display:flex;flex-direction:column;gap:14px;}
    .grid-4{display:grid;grid-template-columns:repeat(4,1fr);gap:12px;}
    .value{font-size:18px;font-weight:700;color:#fff;}
    .label{font-size:12px;color:var(--muted);margin-top:6px;}
    table{width:100%;border-collapse:collapse;margin-top:8px;font-size:13px;}
    th,td{padding:10px 8px;border-bottom:1px solid rgba(255,255,255,0.03);text-align:left;}
    th{color:var(--accent);font-weight:700;}
    .center{text-align:center;}
    footer{padding:14px;text-align:center;color:var(--muted);font-size:12px;}
    @media(max-width:980px){.container{grid-template-columns:1fr;padding:12px;}.grid-4{grid-template-columns:repeat(2,1fr);}}
    .pill{display:inline-block;padding:6px 10px;border-radius:16px;background:#222;color:#fff;font-weight:600;}
    #disclaimer {
  transition: all 0.3s ease;
}
#disclaimer:hover {
  background: rgba(255,255,255,0.05);
  transform: scale(1.01);
}
#disclaimer p {
  margin: 6px 0;
}
  </style>
</head>
<body>
<header><h1>USDT Staking ‚Äî Full DApp</h1></header>
<div class="topbar">
  <div id="walletDisplay" class="muted">Not connected</div>
  <button id="connectBtn" class="wallet-btn">Connect Wallet</button>
</div>

<main class="container">

  <!-- LEFT: Actions -->
  <div class="left">

    <div class="card">
      <h2>Stake USDT</h2>
      <div class="muted">Min stake: <strong>20 USDT</strong> ‚Äî multiples of 20</div>
      <!-- main stake input -->
      <input id="stakeAmt" type="number" placeholder="Enter amount (20,40...)" />
      <div style="display:flex;gap:10px;margin-top:8px">
        <button id="approveBtn" class="small-btn">Quick Approve</button>
        <button id="stakeBtn" class="accent-btn">Stake Now</button>
      </div>
      <div id="stakeNote" class="muted" style="margin-top:8px">Tip: Approve once then stake.</div>
    </div>

    <div class="card">
      <h2>P2P Stake (Stake For)</h2>
      <div class="muted">Stake for another wallet ‚Äî no 5% fee (owner required as refForRefUser)</div>
      <input id="p2pAmount" type="number" placeholder="P2P amount (min 20)" />
      <input id="p2pAddress" type="text" placeholder="Recipient wallet address" style="margin-top:8px" />
      <button id="stakeForBtn" class="accent-btn" style="margin-top:10px">Stake For (P2P)</button>
    </div>

    <div class="card">
      <h2>Your Referral Link</h2>
      <input id="refLink" type="text" readonly placeholder="Connect wallet to generate link" />
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="copyLink" class="small-btn">Copy Referral Link</button>
        <button id="showTeam" class="small-btn">Show Team</button>
      </div>
      <div class="muted" style="margin-top:8px">Users who register via this link will credit you referral income.</div>
    </div>

    <div class="card">
      <h2>Withdraw</h2>
      <div class="muted">Minimum withdraw 20 USDT (admin approval applies)</div>
      <input id="withdrawAmt" type="number" placeholder="20, 40, 60 ..." />
      <button id="requestWithdraw" class="accent-btn" style="margin-top:8px">Request Withdraw</button>
      <div id="withdrawStatus" class="muted" style="margin-top:8px">No withdraw requests yet.</div>
    </div>

  </div>

  <!-- RIGHT: Dashboard -->
  <div class="right">

    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><h2>Wallet Balances & Income</h2><div class="muted">Instant / Level / ROI</div></div>
        <div><button id="refreshBtn" class="small-btn">Refresh</button></div>
      </div>

      <div style="margin-top:12px" class="grid-4">
        <div class="card" style="background:#0b0d0f;padding:12px;">
          <div class="label">Instant Income</div>
          <div class="value" id="instantIncome">0.000000 USDT</div>
        </div>
        <div class="card" style="background:#0b0d0f;padding:12px;">
          <div class="label">Level income</div>
          <div class="value" id="levelIncome">0.000000 USDT</div>
        </div>
        <div class="card" style="background:#0b0d0f;padding:12px;">
          <div class="label">ROI Pending</div>
          <div class="value" id="roiPending">0.000000 USDT</div>
        </div>
        <div class="card" style="background:#0b0d0f;padding:12px;">
          <div class="label">Total Wallet</div>
          <div class="value" id="totalWallet">0.000000 USDT</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Staking Info</h2>
      <table>
        <tr><td>Staked</td><td id="stakedDisplay">0.000000 USDT</td></tr>
        <tr><td>Target (3x)</td><td id="targetDisplay">0.000000 USDT</td></tr>
        <tr><td>Days to 3x</td><td id="days3x">0 days</td></tr>
        <tr><td>Package Status</td><td id="pkgStatus">Inactive</td></tr>
      </table>
    </div>
    <!-- ===== Progress Bar (3x Target) ===== -->
<div id="progressSection" style="margin-top: 15px;">
  <p style="margin-bottom: 6px; color: #ffcc00; font-weight: bold;">Progress to 3x </p>
  <div style="width:100%; background:#333; border-radius:8px; height:10px; overflow:hidden;">
    <div id="progressFill" style="height:100%; width:0%; background:linear-gradient(90deg,#ffcc00,#00ff99); transition:width 1s;"></div>
  </div>
  <p id="progressLabel" style="margin-top:4px; font-size:13px; color:#aaa;">0% completed</p>
</div>


    <div class="card">
      <h2>Team & Levels</h2>
      <div style="display:flex; gap:12px; align-items:center;">
        <div style="flex:1"><div class="muted">Direct</div><div class="value" id="directCount">0</div></div>
        <div style="flex:1"><div class="muted">Indirect</div><div class="value" id="indirectCount">0</div></div>
        <div style="flex:2"><div class="muted">Active / Inactive</div><div class="value" id="activeCounts">0 / 0</div></div>
      </div>

      <div style="margin-top:12px">
        <table>
          <thead><tr><th>Level</th><th>Percent</th><th>Status</th></tr></thead>
          <tbody id="levelsTbody">
            <tr><td>L1</td><td>10%</td><td id="sL1">Pending</td></tr>
            <tr><td>L2</td><td>10%</td><td id="sL2">Pending</td></tr>
            <tr><td>L3</td><td>5%</td><td id="sL3">Pending</td></tr>
            <tr><td>L4</td><td>3%</td><td id="sL4">Pending</td></tr>
            <tr><td>L5</td><td>2%</td><td id="sL5">Pending</td></tr>
            <tr><td>L6</td><td>1%</td><td id="sL6">Pending</td></tr>
            <tr><td>L7</td><td>1%</td><td id="sL7">Pending</td></tr>
            <tr><td>L8</td><td>1%</td><td id="sL8">Pending</td></tr>
            <tr><td>L9</td><td>1%</td><td id="sL9">Pending</td></tr>
            <tr><td>L10</td><td>1%</td><td id="sL10">Pending</td></tr>
          </tbody>
        </table>
      </div>
    </div>

  </div>
</main>
<div class="card">
  <h3>Withdrawal History (Requests & Approved)</h3>
  <div class="history-table">
    <table id="withdrawHistory">
      <thead><tr><th>When</th><th>Amount</th><th>Approved</th><th>TX</th></tr></thead>
      <tbody id="withdrawHistoryBody"><tr><td colspan="4" class="center muted">No history yet.</td></tr></tbody>
    </table>
  </div>
</div>

<!-- üß© DISCLAIMER SECTION -->
<footer id="disclaimer" style="margin-top:60px;padding:25px 12px;text-align:center;background:rgba(255,255,255,0.03);border-top:1px solid rgba(255,255,255,0.07);font-size:14px;line-height:1.6;color:#bbb;backdrop-filter:blur(8px);">
  <div style="max-width:900px;margin:auto;">
    <h3 style="color:#fff;font-size:16px;margin-bottom:8px;">‚ö†Ô∏è Disclaimer</h3>
    <p>
      This decentralized application (DApp) operates entirely on blockchain smart contracts.
      The platform team does <strong>not control or guarantee</strong> returns, profits, or user funds.
      All staking, deposits, and withdrawals are processed automatically by the verified smart contract.
    </p>
    <p>
      Users are advised to <strong>do their own research (DYOR)</strong> before investing or interacting with any smart contract.
      Cryptocurrency investments are subject to market risk, smart contract vulnerabilities, and potential loss of funds.
    </p>
    <p style="margin-top:10px;">
      By using this DApp, you agree that you are participating voluntarily and take full responsibility for your decisions.
    </p>
    <div style="margin-top:14px;font-size:13px;color:#888;">
      &copy; <script>document.write(new Date().getFullYear());</script> USDT Staking dashboard. All rights reserved.
    </div>
  </div>
</footer>
<!-- üß© END DISCLAIMER -->

<footer>Made with ‚ù§Ô∏è ‚Äî Testnet only while testing</footer>

<script>
/* ================================================================
   FINAL INTEGRATED SCRIPT ‚Äî blockchain ROI + P2P/withdraw + team fix
   - Uses readProvider (RPC) for logs and read calls
   - Uses signer (MetaMask) for transactions
   - Builds levels up to 10 using Registered events
================================================================== */

const CONFIG = {
 stakingAddress: "0xe655396c1b8c3617a86d374ec7ad8f1471c12f2f",
tokenAddress: "0x1a904b37b0d96ba755abba656e4f27bf8c89aa",

  decimals: 6,
  // optional: tune fromBlock to contract deploy block for faster log fetch
  logsFromBlock: 0
};

// --- Staking Contract Address & ABI ---
const STAKING_ADDRESS = CONFIG.stakingAddress;
const rpcURL = "https://data-seed-prebsc-1-s1.binance.org:8545"; // BSC Testnet RPC

// Providers & contracts (initialized at run-time)
let readProvider = null;     // read-only RPC provider (getLogs, view)
let web3Provider = null;     // MetaMask provider
let signer = null;           // MetaMask signer
let stakingRead = null;      // read-only staking contract (readProvider)
let stakingWrite = null;     // write staking contract (signer)
let tokenRead = null;        // read-only token
let tokenWrite = null;       // token with signer
let account = null;

// Minimal ABIs (you have larger ABI; include extra functions if needed)
const STAKING_ABI = [
  {"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"address","name":"ref","type":"address"}],"name":"stake","outputs":[],"stateMutability":"nonpayable","type":"function"},
  {"inputs":[{"internalType":"address","name":"refUser","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"address","name":"refForRefUser","type":"address"}],"name":"stakeFor","outputs":[],"stateMutability":"nonpayable","type":"function"},
  {"inputs":[{"internalType":"uint256","name":"amt","type":"uint256"}],"name":"requestWithdrawal","outputs":[],"stateMutability":"nonpayable","type":"function"},
  {"inputs":[{"internalType":"address","name":"usr","type":"address"}],"name":"getTimeTo3x","outputs":[{"internalType":"uint256","name":"daysLeft","type":"uint256"}],"stateMutability":"view","type":"function"},
  {"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"users","outputs":[
    {"internalType":"address","name":"referrer","type":"address"},
    {"internalType":"uint256","name":"totalStake","type":"uint256"},
    {"internalType":"uint256","name":"totalWithdrawn","type":"uint256"},
    {"internalType":"uint256","name":"totalEarned","type":"uint256"},
    {"internalType":"uint256","name":"lastRoiUpdate","type":"uint256"},
    {"internalType":"uint256","name":"roiIncome","type":"uint256"},
    {"internalType":"uint256","name":"instantIncome","type":"uint256"},
    {"internalType":"uint256","name":"levelIncome","type":"uint256"},
    {"internalType":"bool","name":"isActive","type":"bool"},
    {"internalType":"bool","name":"isPaused","type":"bool"},
    {"internalType":"uint256","name":"inactiveAt","type":"uint256"}
  ],"stateMutability":"view","type":"function"},
  {"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"registered","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},
  {"inputs":[{"internalType":"address","name":"ref","type":"address"}],"name":"register","outputs":[],"stateMutability":"nonpayable","type":"function"},
  {"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
  {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":true,"internalType":"address","name":"referrer","type":"address"}],"name":"Registered","type":"event"},
  {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Staked","type":"event"},
  {"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"id","type":"uint256"}],"name":"WithdrawalRequested","type":"event"}
];

const TOKEN_ABI = [
  "function balanceOf(address) view returns (uint256)",
  "function approve(address,uint256) returns (bool)"
];

/* ---------- helpers ---------- */
const fromUnits = bn => Number(ethers.utils.formatUnits(bn || 0, CONFIG.decimals));
const toNum = (v, d=2)=>Number(v).toLocaleString('en-US',{minimumFractionDigits:d,maximumFractionDigits:d});

/* ---------- UI ---------- */
function updateProgressBar(staked,target,earned){
  const fill=document.getElementById("progressFill");
  const label=document.getElementById("progressLabel");
  if(!fill||!label)return;
  const pct=target>0?Math.min(100,(earned/target)*100):0;
  fill.style.width=pct.toFixed(2)+"%";
  label.innerText=`${pct.toFixed(2)}% completed`;
}

/* ---------- PROVIDER INIT ---------- */
async function initProviders() {
  // initialize read-only RPC provider
  readProvider = new ethers.providers.JsonRpcProvider(rpcURL);
  console.log("üîå Read provider ready");

  // if MetaMask already connected, create web3Provider and signer
  if (window.ethereum && (window.ethereum.selectedAddress || window.ethereum._selectedAddress)) {
    web3Provider = new ethers.providers.Web3Provider(window.ethereum, "any");
    signer = web3Provider.getSigner();
    console.log("üîê Web3 provider & signer ready (detected)");
  }
}

/* ---------- CONNECT (user action) ---------- */
async function initProviderWithWeb3() {
  if (!window.ethereum) {
    alert("Install MetaMask");
    return;
  }
  await window.ethereum.request({ method: "eth_requestAccounts" });
  web3Provider = new ethers.providers.Web3Provider(window.ethereum, "any");
  signer = web3Provider.getSigner();
  account = await signer.getAddress();

  // Setup contracts: read-only (RPC) & write (signer)
  stakingRead = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, readProvider);
  stakingWrite = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, signer);
  tokenRead = new ethers.Contract(CONFIG.tokenAddress, TOKEN_ABI, readProvider);
  tokenWrite = new ethers.Contract(CONFIG.tokenAddress, TOKEN_ABI, signer);

  // convenience: set stakingContract variable used by old code paths (write)
  // Note: prefer stakingRead for reads and stakingWrite for txs
  window.stakingContract = stakingWrite;
  window.tokenContract = tokenWrite;

  // UI updates
  const wd = document.getElementById("walletDisplay");
  if (wd) wd.innerText = account;
  const ref = document.getElementById("refLink");
  if (ref) ref.value = window.location.origin + "?ref=" + account;

  attachHandlers();
  attachListeners();
  await refreshAll();

  console.log("‚úÖ MetaMask connected:", account);
}

/* ---------- CONNECT BUTTON ---------- */
async function connect() {
  try {
    if (!readProvider) await initProviders();
    await initProviderWithWeb3();
  } catch (e) {
    console.error("connect failed:", e);
    alert("Connect failed: " + (e.message || e));
  }
}
const connectBtn = document.getElementById("connectBtn");
if (connectBtn) connectBtn.onclick = connect;

/* ---------- HANDLERS (attach once) ---------- */
function attachHandlers(){
  if (window._attachedHandlers) return;
  window._attachedHandlers = true;

  const approveBtn = document.getElementById("approveBtn");
  if (approveBtn) approveBtn.onclick = async ()=>{
    try{
      const tx = await tokenWrite.approve(CONFIG.stakingAddress, ethers.constants.MaxUint256);
      await tx.wait();
      alert("Approved");
      await refreshAll();
    }catch(e){ console.error(e); alert("Approve failed"); }
  };

  const stakeBtn = document.getElementById("stakeBtn");
  if (stakeBtn) stakeBtn.onclick = async ()=>{
    try{
      const amt = document.getElementById("stakeAmt").value;
      if (!amt || Number(amt) < 20) return alert("Min 20 USDT");
      const ref = new URLSearchParams(window.location.search).get("ref") || ethers.constants.AddressZero;
      const tx = await stakingWrite.stake(ethers.utils.parseUnits(String(amt), CONFIG.decimals), ref);
      await tx.wait();
      alert("Stake done");
      await refreshAll();
    }catch(e){ console.error("stake failed", e); alert("Stake failed"); }
  };

  const stakeForBtn = document.getElementById("stakeForBtn");
  if (stakeForBtn) stakeForBtn.onclick = async ()=>{
    try{
      const amt = document.getElementById("p2pAmount").value;
      const addr = document.getElementById("p2pAddress").value;
      if (!amt || Number(amt) < 20) return alert("Min 20 USDT");
      if (!ethers.utils.isAddress(addr)) return alert("Bad address");
      const owner = await stakingRead.owner(); // read via readProvider
      const tx = await stakingWrite.stakeFor(addr, ethers.utils.parseUnits(String(amt), CONFIG.decimals), owner);
      await tx.wait();
      alert("P2P stake done");
      await refreshAll();
    }catch(e){ console.error("stakeFor failed", e); alert("P2P stake failed"); }
  };

  const reqWithdrawBtn = document.getElementById("requestWithdraw");
  if (reqWithdrawBtn) reqWithdrawBtn.onclick = async ()=>{
    try{
      const amt = document.getElementById("withdrawAmt").value;
      if (!amt || Number(amt) < 20) return alert("Min 20");
      const tx = await stakingWrite.requestWithdrawal(ethers.utils.parseUnits(String(amt), CONFIG.decimals));
      await tx.wait();
      alert("Withdrawal requested");
      await refreshAll();
    }catch(e){ console.error("requestWithdraw failed", e); alert("Request failed"); }
  };

  const refreshBtn = document.getElementById("refreshBtn");
  if (refreshBtn) refreshBtn.onclick = refreshAll;

  const showTeamBtn = document.getElementById("showTeam");
  if (showTeamBtn) showTeamBtn.onclick = loadTeamInfo;

  const copyLink = document.getElementById("copyLink");
  if (copyLink) copyLink.onclick = async ()=>{
    try{
      await navigator.clipboard.writeText(document.getElementById("refLink").value);
      alert("Link copied");
    }catch(e){ alert("Copy failed"); }
  };
}

/* ---------- EVENTS: listen for on-chain events (read contracts) ---------- */
function attachListeners(){
  // attach only once
  if (window._listenersAttached) return;
  window._listenersAttached = true;

  // Use stakingRead (readProvider) to get events reliably
  try{
    if (!stakingRead) stakingRead = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, readProvider);
    stakingRead.on("Staked", (user, amount) => {
      console.log("Event Staked:", user, fromUnits(amount));
      refreshAll();
    });
    stakingRead.on("WithdrawalRequested", (user, id) => {
      console.log("Event WithdrawalRequested:", user, id);
      refreshAll();
    });
    stakingRead.on("Registered", (user, referrer) => {
      console.log("Event Registered:", user, referrer);
      // update team for connected account (debounced little)
      setTimeout(()=>{ if (account) loadTeamInfo(); }, 500);
    });
  }catch(e){ console.warn("attachListeners failed", e); }
}

/* ---------- ROI + DASH ---------- */
async function forceUpdateROI(){
  try{
    // Prefer read contract
    const info = await stakingRead.users(account);
    const roi = fromUnits(info.roiIncome);
    const el = document.getElementById("roiPending");
    if (el) el.innerText = `${toNum(roi,6)} USDT`;
    return roi;
  }catch(e){
    console.warn("forceUpdateROI failed", e);
    return 0;
  }
}

/* ---------- TEAM FROM EVENTS (single robust function using readProvider) ---------- */
async function getTeamFromEvents_readRPC(rootAccount) {
  try {
    if (!readProvider) await initProviders();
    const iface = new ethers.utils.Interface(STAKING_ABI);
    const registeredTopic = iface.getEventTopic("Registered");

    console.log("üì° Fetching Registered logs from RPC... (this may take a moment)");

    const logs = await readProvider.getLogs({
      fromBlock: CONFIG.logsFromBlock || 0,
      toBlock: "latest",
      address: STAKING_ADDRESS,
      topics: [registeredTopic],
    });

    const childrenMap = new Map();
    for (const log of logs) {
      try {
        const parsed = iface.parseLog(log);
        const user = String(parsed.args.user || parsed.args[0] || "").toLowerCase();
        // try common names for ref parameter
        const refAddr = String(parsed.args.referrer || parsed.args.ref || parsed.args[1] || ethers.constants.AddressZero).toLowerCase();
        if (!childrenMap.has(refAddr)) childrenMap.set(refAddr, new Set());
        childrenMap.get(refAddr).add(user);
      } catch (e) {
        // ignore logs we cannot parse
        continue;
      }
    }

    // BFS up to 10 levels starting from rootAccount
    const maxLevels = 10;
    const root = rootAccount.toLowerCase();
    const levels = [];
    const seen = new Set();

    const l1 = childrenMap.has(root) ? Array.from(childrenMap.get(root)) : [];
    levels.push(l1);
    l1.forEach(a => seen.add(a));

    for (let lvl = 2; lvl <= maxLevels; lvl++) {
      const prev = levels[lvl - 2] || [];
      if (!prev.length) { levels.push([]); continue; }
      const thisLevel = [];
      for (const parent of prev) {
        const kids = childrenMap.get(parent) || new Set();
        for (const k of kids) {
          if (!seen.has(k) && k !== root) { seen.add(k); thisLevel.push(k); }
        }
      }
      levels.push(thisLevel);
    }

    console.log(`‚úÖ getTeamFromEvents_readRPC: built levels [${levels.map(l=>l.length).join(', ')}]`);
    return { levels };
  } catch (err) {
    console.error("getTeamFromEvents_readRPC error:", err);
    return { levels: [] };
  }
}

/* ---------- TEAM UI ---------- */
async function updateTeamUI(levels) {
  try {
    const lvlArr = levels || [];
    const directList = lvlArr[0] || [];
    const indirectList = [].concat(...(lvlArr.slice(1)));
    const directCount = directList.length;
    const indirectCount = indirectList.length;

    let active = 0, inactive = 0;
    const combined = [...directList, ...indirectList];

    // Use read contract for user info calls
    for (const addr of combined) {
      try {
        const info = await stakingRead.users(addr).catch(()=>null);
        if (!info) { active++; continue; }
        const st = fromUnits(info.totalStake || info[2] || 0);
        const isAct = (info.isActive === true) || (st > 0);
        if (isAct) active++; else inactive++;
      } catch (e) {
        console.warn("updateTeamUI: user fetch failed", addr, e);
        active++;
      }
    }

    const directEl = document.getElementById("directCount");
    const indirectEl = document.getElementById("indirectCount");
    const activeEl = document.getElementById("activeCounts");
    if (directEl) directEl.innerText = directCount;
    if (indirectEl) indirectEl.innerText = indirectCount;
    if (activeEl) activeEl.innerText = `${active} / ${inactive}`;

    // update level rows visual (if present)
    const rows = document.querySelectorAll("#levelsTbody tr");
    rows.forEach((r, i) => {
      const cell = r.querySelector("td:last-child");
      if (!cell) return;
      if (i < Math.min(directCount, 10)) {
        cell.innerText = "Open ‚úÖ";
        cell.style.color = "#00FF90";
        cell.style.fontWeight = "600";
      } else {
        cell.innerText = "Pending";
        cell.style.color = "";
        cell.style.fontWeight = "";
      }
    });

    console.log(`‚úÖ Team updated ‚Äî Directs: ${directCount}, Indirects: ${indirectCount}, Active: ${active}, Inactive: ${inactive}`);
  } catch (e) {
    console.error("updateTeamUI error:", e);
  }
}

/* ---------- LOAD TEAM INFO (tries RPC -> cache fallback) ---------- */
async function loadTeamInfo(){
  try{
    if (!readProvider) await initProviders();
    if (!account) {
      console.log("loadTeamInfo: no account connected");
      return;
    }
    console.log("üîç Loading team (safe mode)...");

    // Try on-chain via read RPC
    try{
      console.log("üü¶ Fetching team from read RPC...");
      const { levels } = await getTeamFromEvents_readRPC(account);
      // cache
      try { localStorage.setItem("team_levels_" + account.toLowerCase(), JSON.stringify(levels)); } catch(e){}
      await updateTeamUI(levels);

      // attach realtime listener to update when new Registered events fire
      if (!window._teamListenerAdded) {
        window._teamListenerAdded = true;
        try {
          // use read contract to listen
          if (!stakingRead) stakingRead = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, readProvider);
          stakingRead.on("Registered", async (user, referrer) => {
            try{
              console.log("Registered event detected - rebuilding team");
              const { levels: newLevels } = await getTeamFromEvents_readRPC(account);
              try { localStorage.setItem("team_levels_" + account.toLowerCase(), JSON.stringify(newLevels)); } catch(e){}
              await updateTeamUI(newLevels);
            }catch(e){ console.warn("registered handler error", e); }
          });
        } catch(e){ console.warn("Failed to attach Registered listener", e); }
      }

      return;
    } catch(chainErr){
      console.warn("Fetching team from RPC failed:", chainErr);
    }

    // fallback: cached levels
    try{
      const raw = localStorage.getItem("team_levels_" + account.toLowerCase());
      const cached = raw ? JSON.parse(raw) : [];
      if (cached && cached.length) {
        console.log("üü® Using cached team levels");
        await updateTeamUI(cached);
        return;
      }
    } catch(e){ console.warn("team cache read failed", e); }

    // no data
    console.log("‚ö†Ô∏è No team data found (onchain & cache empty)");
    await updateTeamUI([]);
  }catch(e){
    console.error("loadTeamInfo error:", e);
  }
}

/* ---------- REFRESH ALL (dashboard) ---------- */
async function refreshAll(){
  try{
    if (!readProvider) await initProviders();
    if (!signer || !account) {
      // attempt to set account if web3 connected
      if (web3Provider && !account) {
        try { signer = web3Provider.getSigner(); account = await signer.getAddress(); } catch(e){}
      }
    }
    // if we have no connected account, update only read info
    if (!account) {
      console.log("refreshAll: no account connected - skipping user-specific UI updates");
      return;
    }

    // balance (read via readProvider and tokenRead if available)
    let bal = 0;
    try{
      if (!tokenRead) tokenRead = new ethers.Contract(CONFIG.tokenAddress, TOKEN_ABI, readProvider);
      bal = fromUnits(await tokenRead.balanceOf(account));
    }catch(e){ console.warn("balance read failed", e); }

    const walletDisplay = document.getElementById("walletDisplay");
    if (walletDisplay) walletDisplay.innerText = `${account} ‚Äî ${toNum(bal,4)} USDT`;

    // user info (read contract)
    let info;
    try{
      if (!stakingRead) stakingRead = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, readProvider);
      info = await stakingRead.users(account);
    }catch(e){
      console.warn("users() read failed, try using write contract as fallback", e);
      try { info = await stakingWrite.users(account); } catch(e2){ console.error("users fallback failed", e2); info = null; }
    }

    const staked = info ? fromUnits(info.totalStake) : 0;
    const inst = info ? fromUnits(info.instantIncome) : 0;
    const lvl = info ? fromUnits(info.levelIncome) : 0;
    const earned = info ? fromUnits(info.totalEarned) : 0;
    const roi = await forceUpdateROI();
    const total = roi + inst + lvl;

    const stEl = document.getElementById("stakedDisplay");
    if (stEl) stEl.innerText = `${toNum(staked,6)} USDT`;
    const tgtEl = document.getElementById("targetDisplay");
    if (tgtEl) tgtEl.innerText = `${toNum(staked*3,6)} USDT`;
    const instEl = document.getElementById("instantIncome");
    if (instEl) instEl.innerText = `${toNum(inst,6)} USDT`;
    const lvlEl = document.getElementById("levelIncome");
    if (lvlEl) lvlEl.innerText = `${toNum(lvl,6)} USDT`;
    const totEl = document.getElementById("totalWallet");
    if (totEl) totEl.innerText = `${toNum(total,6)} USDT`;
    const pkgEl = document.getElementById("pkgStatus");
    if (pkgEl) pkgEl.innerText = (info && info.isActive) ? "‚úÖ Active" : "Inactive";

    try{
      const d = await stakingRead.getTimeTo3x(account);
      const daysEl = document.getElementById("days3x");
      if (daysEl) daysEl.innerText = `${Number(d)} days`;
    }catch(e){ console.warn("getTimeTo3x failed", e); const daysEl = document.getElementById("days3x"); if (daysEl) daysEl.innerText="N/A"; }

    updateProgressBar(staked, staked*3, earned);

    // load team & withdraw history
    await loadTeamInfo();
    await loadWithdrawHistory();
  }catch(e){
    console.error("refreshAll failed", e);
  }
}

/* ---------- WITHDRAW HISTORY ---------- */
async function loadWithdrawHistory(){
  const tb=document.getElementById("withdrawHistoryBody");
  if (!tb) return;
  tb.innerHTML='<tr><td colspan="4" class="center muted">Loading...</td></tr>';
  try{
    // NOTE: contract methods nextWithdrawId() and withdrawals(i) must exist on your contract ABI
    if (!stakingRead) stakingRead = new ethers.Contract(STAKING_ADDRESS, STAKING_ABI, readProvider);
    // try to read nextWithdrawId (if present)
    let n = 0;
    try { n = Number(await stakingRead.nextWithdrawId()); } catch(e) { console.warn("nextWithdrawId not available", e); n = 0; }

    let html = "";
    for (let i = n-1; i >= 1; i--) {
      try {
        const r = await stakingRead.withdrawals(i);
        if (!r || !r.user) continue;
        if (String(r.user).toLowerCase() !== account.toLowerCase()) continue;
        const t = new Date(Number(r.timestamp) * 1000).toLocaleString();
        html += `<tr><td>${t}</td><td>${toNum(fromUnits(r.amount),2)} USDT</td><td>${r.approved ? "‚úÖ Approved" : "‚è≥ Pending"}</td><td>${i}</td></tr>`;
      }catch(e){
        // ignore missing entries
        continue;
      }
    }
    tb.innerHTML = html || '<tr><td colspan="4" class="center muted">No history</td></tr>';
  }catch(e){
    console.error("loadWithdrawHistory failed", e);
    tb.innerHTML = '<tr><td colspan="4">Error</td></tr>';
  }
}

/* ---------- CHAIN EVENTS (auto reload on change) ---------- */
if (window.ethereum) {
  window.ethereum.on("accountsChanged", ()=> location.reload());
  window.ethereum.on("chainChanged", ()=> location.reload());
}

/* ---------- AUTO INIT ---------- */
(async function boot(){
  try{
    await initProviders();
    console.log("‚úÖ Boot done - read provider ready.");
    // If MetaMask is already available and connected, attempt auto init (non-blocking)
    if (window.ethereum && (window.ethereum.selectedAddress || window.ethereum._selectedAddress)) {
      try { await initProviderWithWeb3(); } catch(e){ console.warn("Auto-web3 init failed", e); }
    }
  }catch(e){ console.error("boot failed", e); }
})();

console.log("‚úÖ Final JS integrated ‚Äî read/write separated, team level builder ready.");
</script>
